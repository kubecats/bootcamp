<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <select name="" id="city"></select>
    <button onclick="doSearch()">조회</button>
    <button>라인추가</button>
    <button>라인삭제</button>

    <table>
      <thead>
        <tr>
          <th>음료</th>
          <th>가격</th>
        </tr>
      </thead>
      <tbody id="tableTbody"></tbody>
    </table>

    <script>
      // Array 객체 (가장 중요함)
      let brands = ["애플", "구글", "메타", "아마존", "네이버", "카카오"];

      // * toString()
      console.log(brands.toString());

      // * join() (정말 많이 사용됨)
      // 배열을 문자열로 만들어주는 함수인듯?
      console.log(brands.join(", "));

      function doSearch() {
        const productList = [
          // 음료 리스트
          {
            name: "솔의눈",
            price: 700,
          },
          {
            name: "커피",
            price: 700,
          },
          {
            name: "파워에이드",
            price: 1200,
          },
          {
            name: "오렌지",
            price: 1000,
          },
          {
            name: "보리차",
            price: 1200,
          },
          {
            name: "밀키스",
            price: 800,
          },
        ];

        //   let h = "";
        let h = [];
        //   h[0] = 1;
        //   h[1] = 2;
        //   h.push[1];
        //   h.push[2];

        // * push();
        for (const product of productList) {
          // h += "<tr>";
          // h += "<td>" + product.name + "</td>";
          // h += "<td>" + product.price + "</td>";
          // h += "<tr>";

          h.push("<tr>");
          h.push("<td>" + product.name + "</td>");
          h.push("<td>" + product.price + "</td>");
          h.push("<tr>");
        }

        //   console.log(h);

        //   document.getElementById("tableTbody").innerHTML = h;
        document.getElementById("tableTbody").innerHTML = h.join("");
      }

      // * pop() 배열의 뒤에서부터 빼냄
      console.log(brands.pop());
      console.log(brands.pop());

      // * shift() 배열의 앞에서부터 빼냄, 실무에서 굉장히 많이 쓰임
      console.log(brands.shift());
      console.log(brands.shift());

      let sendMsg = [];
      let eventQueue = [];

      // * unshift()
      brands.unshift("삼성전자");
      console.log(brands);

      function loadCity(needAll) {
        let cities = [
          { code: "02", title: "서울" },
          { code: "21", title: "부산" },
          { code: "064", title: "제주" },
        ];

        let h = [];

        for (const city of cities) {
          h.push(
            '<option value="' + city.code + '">' + city.title + "</option>"
          );
        }

        if (needAll) {
          h.unshift('<option value="">==전체==</option>');
        }

        document.getElementById("city").innerHTML = h.join("");
      }

      loadCity(true);

      // * splice(), 몇 번째 index에 추가할 것인가?,
      brands.splice(1, 0, "리턴밸류", "더그레잇");
      console.log(brands);

      // * concat(), 배열의 결합
      let arr1 = ["A", "B"];
      let arr2 = ["C", "D"];
      let arr3 = ["E", "F"];

      let arr4 = arr1.concat(arr2, arr3);
      console.log(arr4);

      // * 배열의 결합시 concat 보다 많이 사용됨
      let arr5 = [...arr1, ...arr2, ...arr3];
      console.log(arr5);

      // * slice (자르고 싶은 시작 index, 종료 index)
      console.log(arr4.slice(1, 2)); //배열로 return됨

      // * sort()
      //   console.log(productList.sort());
      brands = ["애플", "구글", "메타", "아마존", "네이버", "카카오"];

      console.log("brand 정렬 : ", brands.sort());

      // 정렬하면 순서가 숫자 순서대로 정렬이 안된다.
      let points = [40, 100, 1, 5, 25, 10];
      console.log("point 정렬 : ", points.sort());

      // 이렇게 해야 숫자순서대로 정렬이 된다.
      // 음수값이면 위치를 바꾸지 않는다. 양수값이면 위치를 바꾼다.
      // 오름차순
      function numberSortAsc(a, b) {
        // a: 40, b: 100
        // a: 100, b:1
        // [40,1,100,5,25,10]
        // a: 100, b:5
        // [40,1,5,100,25,10]
        // a: 100, b:25
        // [40,1,5,25,100,10]
        // a: 100, b:10
        // [40,1,5,25,10,100]
        // a: 40, b:1
        // [1,40,5,25,10,100]
        // a: 40, b:5
        // [1,5,40,25,10,100]
        // a: 40, b:25
        // [1,5,25,40,10,100]
        // a: 40, b: 10
        // [1,5,25,10,40,100]
        // a:40, b:100
        // a:1, b:5
        // a:5, b: 25
        // a: 25, b:10
        // [1,5,10,25,40,100]
        return a - b;
      }

      // 내림차순
      function numberSortDsc(a, b) {
        return b - a;
      }

      console.log(points.sort(numberSortAsc));
      console.log(points.sort(numberSortDsc));

      // 문자열 정렬
      const productList = [
        // 음료 리스트
        {
          name: "솔의눈",
          price: 700,
        },
        {
          name: "커피",
          price: 700,
        },
        {
          name: "파워에이드",
          price: 1200,
        },
        {
          name: "오렌지",
          price: 1000,
        },
        {
          name: "가봉",
          price: 1000,
        },

        {
          name: "보리차",
          price: 1200,
        },
        {
          name: "밀키스",
          price: 800,
        },
      ];

      function objectSort(a, b) {
        if (a.name > b.name) return 1;
        else if (a.name < b.name) return -1;
        else return 0;
      }

      function pricsSort(a, b) {
        // if (a.price > b.price) return 1;
        // else if (a.price < b.price) return -1;
        // else return 0;

        // sort함수는 1, -1 만 만들어주면 됨
        return a.price - b.price;
      }

      console.log(productList.sort(objectSort));
      console.log(productList.sort(pricsSort));

      // * filter() (가장 잘 쓰는 함수임)
      // 700원 갖고 사먹을수 있는 음료수 출력
      // filter 함수를 사용하지 않고 개발하는 방법
      newProductList = [];
      const inputCoin = 700;
      for (const product of productList) {
        if (product.price <= inputCoin) {
          newProductList.push(product);
        }
      }

      console.log(newProductList);

      // function doFilter(product) {
      //     if (product.price <= inputCoin) {
      //       return true;
      //     } else {
      //       return false;
      //     }
      //   }

      // return product.price <= inputCoin ? true : false;

      // newProductList = productList.filter(doFilter);
      // newProductList = productList.filter(function(product){return product.price <= inputCoin ? true : false;});

      // console.log(newProductList);

      //   console.log(productList.filter((p) => p.price <= inputCoin));

      // * map()
      let userList = [
        {
          firstName: "재석",
          lastName: "유",
          email: "yu@gmail.com",
        },
        {
          firstName: "종국",
          lastName: "김",
          email: "kim@gmail.com",
        },
        {
          firstName: "흥국",
          lastName: "김",
          email: "kim@gmail.com",
        },
        {
          firstName: "세찬",
          lastName: "양",
          email: "yang@gmail.com",
        },
        {
          firstName: "석진",
          lastName: "지",
          email: "ji@gmail.com",
        },
      ];

      // 서버에서 받아오는 정보를 선택적으로 보여줄 수 있음
      function newUserMap(user) {
        return {
          firstName: user.firstName,
          //lastName: user.lastName,
          email: user.email,
          fullName: user.lastName + user.firstName,
        };
      }

      let userList2 = userList.map(newUserMap);
      console.log(userList2);

      // * reduce()

      points = [80, 90, 95, 78, 88, 100, 92];
      let sum = points.reduce(function (
        accumulator,
        currentValue,
        currentIndex,
        arr
      ) {
        // accumulator : 누적 값
        // currentValue : 현재 배열 요소
        // currentIndex : 현재 배열 인덱스 번호
        // arr : 전체 배열

        return accumulator + currentValue;
      },
      0);
      console.log(sum);

      let sum2 = productList.reduce(function (
        accumulator,
        currentValue,
        currentIndex,
        arr
        // total,
        // product
      ) {
        // 첫 번째 - accumulator : 누적 값
        // 두 번째 - currentValue : 현재 배열 요소
        // 세 번째 - currentIndex : 현재 배열 인덱스 번호
        // 네 번째 - arr : 전체 배열
        // 거의 첫번째, 두번째 parameter만 사용됨

        return accumulator + currentValue.price;
        // return total + product.price;
      }, 0);
      //누적값이 들어가는 total의 초기값 입력

      console.log("음료 전체 합계", sum2);

      // userList에서 김씨 성을 갖은 요소만 추출, 하지만 이것은 filter를 사용하는게 빠를 수 있음
      // 숫자를 통한 합계에서만 reduce를 많이 사용함
      let kims = userList.reduce(function (users, user) {
        if (user.lastName === "김") {
          users.push(user);
        }

        return users;
      }, []);

      console.log(kims);
    </script>
  </body>
</html>
